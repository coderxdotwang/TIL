# 2020-06-29 栈（stack）和堆（heap）异同

>*堆* *栈* *内存管理*

C程序在内存中的组织形式，一般一个可执行程序由 4 个区域组成：*代码段*、*静态数据区*、*堆*与*栈*。

代码段包含程序运行时所执行的机器指令。静态数据区包含程序声明周期内一直存在的数据，如全局变量和静态变量。（也有描述为：程序加载到内存后，除了变量组和函数组占用内存空间，还会额外生成两个组，那就是栈和堆。）

堆包含程序运行时动态分配的空间，从低地址向高地址向上增长，栈包含函数调用信息。

C程序调用函数时，栈中会分配一块空间来保存与这个调用相关的信息。栈上那块存储空间被称为活跃记录，或者称为**栈帧**。**栈帧**包含 5 个区域：*输入参数*、*返回值空间*、*计算表达式时用到的临时存储空间*、*函数调用时保存的状态信息*、以及*输出参数*。

##相同点

-----

栈和堆需要的内存空间都是在可执行程序加载到内存后开始运行时申请分配的。

##不同点

线程创建时系统会为其分配一个栈，由程序维护，线程退出时栈释放；堆由应用运行时动态分配，应用进程结束时释放。

栈大小在线程创建时设置，堆大小在应用启动时设置，可以按需增长，例如随着程序运行申请更多空间。

|                       栈 stack                       |                           堆 heap                            |
| :--------------------------------------------------: | :----------------------------------------------------------: |
|            程序启动时就已经设置了最大空间            |                      程序运行时动态分配                      |
|  用来存储函数内部使用的局部变量、函数调用所用的参数  |              用来存储程序运行时的任意数据和对象              |
|                     没有指针指向                     |             通过 new/malloc 分配空间，有指针指向             |
|       自动释放（编译器自动生成分配及释放方法）       |                     手动释放 free/delete                     |
|               较快、后进先出 **LIFO**                |                           相对较慢                           |
|               使用过多时会报栈溢出错误               | 大量的分配和释放会产生碎片，可能会产生内存泄露（处理完毕后没有明确释放内存空间） |
| 当编译前就知道数据需要多少空间（并且不是太大）时使用 |  不能准确知道运行时需要多少空间，或者需要生成大量数据时使用  |



#### 为什么栈比堆快

栈区的后进先出 **LIIFO**（last iin first out） 访问方式使得分配与释放更简单（*push*/*pop* 就是一个机器指令），相比之堆区的分配与释放更复杂（分配与释放堆空间涉及到调用操作系统代码）。同时，栈区往往被高频复用，意味着倾向于映射到处理器的缓存。而堆区是一个全局资源，通常必须是多线程安全的，每次分配释放都需要与程序中‘所有’其他堆访问同步。

### 参考

1. 《算法精解：C语言描述》Kyle Loudon 基本递归
2. 《程序是怎么跑起来的》矢泽久雄 8.8 小节
3. [Stackoverflow-What and where are the stack and heap?](https://stackoverflow.com/q/79923/6288484)

